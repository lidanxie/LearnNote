1.Event(事件) 
	大多数Nodejs核心API都采用惯用的异步事件驱动架构，其中某些类型的对象（触发器会周期性地触发命名事件来调用函数对象（监听器）。

	所有能触发事件的对象都是EventEmitter类的实例。这些对象开放了一个eventEmitter.on()函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。

	当EventEmitter对象触发一个事件时，所有绑定在该事件上的函数都被同步地调用。监听器的返回值会被丢弃。

	例子：一个绑定了一个监听器的EventEmitter实例。eventEmitter.on()方法用于注册监听器,eventEmitter.emit()方法用于触发事件
	const EventEmitter = require('events');

	class MyEmitter extends EventEmitter {}
	const myEmitter = new MyEmitter();
	myEmitter.on('event', () => {
		console.log('触发了一个事件！');
	})
	myEmitter.emit('event');

	1.1 给监听器传入参数与this
		eventEmitter.emit()方法允许将任意参数传给监听器函数。当一个普通的监听器函数被EventEmitter调用时，标准的this关键字会被设置指向监听器所附加的EventEmitter

		const myEmitter = new MyEmitter();
		myEmitter.on('event', function(a,b) {
			console.log(a,b,this);
			//打印
			//a b MyEmitter {
			// domain: null,
			// _events: {event: [Function]},
			// _eventsCount: 1,
			// _maxListeners: undefined
			}
		});
		myEmitter.emit('event', 'a', 'b');

		也可以使用ES6的箭头函数作为监听器。但是这样this关键字就不再指向EventEmitter实例。
		const myEmitter = new MyEmitter();
		myEmitter.on('event', (a,b) => {
			console.log(a,b,this);
			//打印：a b {}
		});
		myEmitter.emit('event', 'a', 'b');

	1.2 异步与同步
			EventListener会按照监听器注册的顺序同步地调用所有监听器。所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用setImmediate()或process.nextTick()方法切换到异步操作模式。

			const myEmitter = new MyEmitter();
			myEmitter.on('event', (a, b) => {
				setImmediate(() => {
					console.log('这个是异步发生的');
				});
			});
			myEmitter.emit('event', 'a', 'b');

	1.3 只处理事件一次
			当使用eventEmitter.on()方法注册监听器时，监听器会在每次触发命名事件时被调用。

			const myEmitter = new MyEmitter();
			let m = 0;
			myEmitter.on('event', () => {
				console.log(++m);
			})
			myEmitter.emit('event');  //打印1
			myEmitter.emit('event');  //打印2

			使用eventEmitter.once()方法时可以注册一个对于特定事件最多被调用一次的监听器。当事件被触发是，监听器会被注销，然后再调用

			const myEmitter = new MyEmitter();
			let m = 0;
			myEmitter.once('event', () => {
				console.log(++m);
			});
			myEmitter.emit('event');  //打印1
			myEmitter.emit('event');   //忽略

	1.4 错误事件
			当EventEmitter实例中发生错误时，会触发一个'error'事件。
			如果EventEmitter没有为'error'事件注册至少一个监听器，则当'error'事件触发时，会抛出错误、打印堆栈跟踪、且退出nodejs进程

			const myEmitter = new MyEmitter();
			myEmitter.emit('error', new Error('whoops!'));    //抛出错误，并使nodejs崩溃

			为了防止Nodejs进程崩溃，可以在process对象的uncaughtException事件上注册监听器，或者使用domain模块。

			const myEmitter = new MyEmitter();
			process.on('uncaughtException', (err) => {
				console.log('有错误');
			});

			最佳实战：始终未error事件注册监听器
			const myEmitter = new MyEmitter();
			myEmitter.on('error', (err) => {
				console.error('有错误');
			})
			myEmitter.emit('error', new Error('whoops!'));

	1.5 EventEmitter类
		const EventEmitter = require('events');

		当新的监听器被添加时，所有的EventEmitter会触发'newListener'事件；当移除已存在的监听器时，则触发'removeListener'

	1.6 newListener事件

		EventEmitter实例会在一个监听器被添加到其内部监听器数组之前触发自身的'newListener'事件

		注册了'newListener'事件的监听器会传入事件名语被添加的监听器的引用。

		const myEmitter = new MyEmitter();
		//只处理一次，所以不会无限循环
		myEmitter.once('newListener', (event, listener) => {
			if(event === 'event') {
				//在开头插入一个新的监听器
				myEmitter.on('event', () => {
					console.log('B');
				});
			}
		});
		myEmitter.on('event', () => {
			console.log('A');
		})
		myEmitter.emit('event');  
		//打印 B A

	1.7 removeListener事件
		removeListener事件在listener后会被移除

	1.8 EventEmitter.defaultMaxListeners
		每个事件默认可以注册最多10个监听器。单个EventEmitter实例的限制可以使用emitter.setMaxListeners(n)方法改变。所有EventEmitter实例的默认值可以使用EventEmitter.defaultMaxListener属性改变。如果不是正数，将会抛出TypeError

		调用emitter.setMaxListener优先于EventEmitter.defaultMaxListeners

		emitter.setMaxListeners(emitter.getMaxListeners() + 1);
		emitter.once('event', () => {
			emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));
		})

	1.9 emitter.addListener(eventaName,listener);
		emitter.on()的别名

	1.10 emitter.emit(eventName)
		按监听器的注册顺序，同步地调用每个注册到名为eventName事件的监听器，并传入提供的参数。
		如果事件有监听器，则返回true,否则返回false

	1.11 emitter.eventNames() 
		返回一个列出触发器已注册监听器的事件的数组。数组中的值为字符串或符号。

		const EventEmitter = require('events');
		const myEE = new EventEmitter();
		myEE.on('foo', () => {});
		myEE.on('bar', () => {});

		const sym = Symbol('symbol');
		myEE.on(sym, () => {});

		console.log(myEE.eventNames);   //['foo','bar',Symbol(symbol)]

	1.12 emitter.listeners(eventName)
		返回eventName的事件的监听器数组的副本
		server.on('connection', (stream) => {
			console.log('someone connected!');
		});
		console.log(util.inspect(server.listeners('connection')));

	1.13 emitter.prependListener(eventName,listener)
		添加listener函数到名为eventName的事件的监听器数组的开头。不会检查listener是否被添加。多次调用并传入相同的eventName和listener会导致listener被添加与调用多次
		server.prependListener('connection', (stream) => {
			console.log('有连接！');
		})

	1.14 emitter.removeListener(eventName,listener)
		从名为eventName的事件监听器数组中移除指定的listener

		const callback = (stream) => {
			console.log('有连接！');
		}
		server.on('connection', calback);
		server.removeListener('connection', callback);

		removeListener最多只会从监听器数组里移除一个监听器实例。如果任何单元的监听器被多次添加指定eventName的监听器数组中，则必须多次调用removeListener才能移除每个实例。

		注意，一旦一个事件被触发，所有绑定到它的监听器都会按顺序依次触发。这意味着，在事件触发后、最后一个监听器完成执行前，任何removeListener()或removeAllListener()调用都不会从emit()中移除它们。随后的事件会想预期那样发生。

		const myEmitter = new MyEmitter();
		const callbackA = () => {
			console.log('A');
			myEmitter.removeListener('event', callbackB);
		};
		const callbackB = () => {
			console.log('B');
		};
		myEmitter.on('event', callbackA);   
		myEmitter.on('event', callbackB);   
		//callbackA移除了监听器callbackB,但它仍然会被调用。
		//触发是内部的监听器数组为：[callbackA,callbackB]
		myEmitter.emit('event'); //A B
		myEmitter.emit('event');  //A

	博客总结：
		观察者模式：就是为某一对象添加一监听事件，由该事件在符合条件时自行触发。
	参考博客链接：https://cnodejs.org/topic/561b869eba66abef398b007d

2. Error(错误)
	参考博客：https://segmentfault.com/a/1190000002741935
	http://www.imooc.com/article/1650
	Nodejs中运行的应用程序一般会遇到以下四类错误：
		标准javascript错误:
			EvalError:当调用eval()失败时抛出
			SyntaxError:当javascript语法错误时抛出
			RangeError:当值不在预期范围内抛出
			ReferenceError:当使用未定义的变量时抛出
			TypeError:当传入错误类型的参数时抛出。
			URIError:当全局的URI处理函数被误用时抛出
		由底层操作系统触发的系统错误；
		由应用程序代码触发的用户自定义的错误；
		断言错误是错误的一个特殊类别，每当Node.js检测到一个不应该发生的异常逻辑时触发。

	2.1 错误的冒泡和捕获
		Node.js支持几种当应用程序运行时发生的错误的冒泡和处理的机制。如何报告和处理这些错误完全取决于错误的类型和被调用的API的风格。

		所有的Javascript错误都会被当做异常处理，异常会立即产生并使用标准的Javascript throw机制抛出一个错误。这些都是使用javascript语言提供的try/catch语言处理的
		如：
		try {
			const m = 1;
			const n = m + z;
		} catch(err) {
			//处理错误
		}

		javascript的throw机制的任何使用都会引起异常，异常必须使用try/catch处理，否则Nodejs进程会立即退出。

		除了少数例外，同步的API(任何不接受callback函数的阻塞方法)会使用throw报告错误

		异步的API中发生的错误可能会以多种方式进行报告：
			大多数的异步方法都接受一个callback函数，该函数会接受一个Error对象传入作为第一个参数。如果第一个参数不是null而是Error实例，则说明发生了错误。
				const fs = require('fs');
				fs.readFile('一个不存在的文件', (err, data) => {
					if(err) {
						console.log('读取文件出错！', err);
						return;
					}
					//否则处理数据
				})
			当一个异步方法被一个EventEmitter对象调用时，错误会被分发到对象的'error'事件上。
				const net = require('net');
				const connection = net.connect('localhost')

3.HTTP
	博客：https://cnodejs.org/topic/58eee565a92d341e48cfe7fc

	要使用http服务器与客户端，需要require('http');
	Nodejs中的http接口被设计成支持协议的许多特性。比如，大块编码的消息。这些接口不缓冲完整的请求或响应时间，用户能够以流的形式处理数据。
	为了支持各种可能的http应用，nodejs的HTTP API是非常底层的。它只设计流处理与消息解析。它把一个消息解析成消息头和消息主体，但不解析具体的消息头或消息主体。

	接收到的消息头保存在rawHeaders属性中，它是一个[key,value,key2,value2...]数组。

	3.1http.Agent类
		Agent负责为HTTP客户端管理连接的持续与复用。它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的socket连接直到队列为空，此时socket会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口号的请求再次使用。是否被销毁或被放入连接池取决于keepAlive选项

		连接池的连接的TCP Keep-Alive是开启的，但服务器仍然可能关闭闲置的连接，在这种情况下，这些连接会被移出连接池，且当一个新的HTTP请求被创建时再为指定的主机与端口号创建一个新的连接。服务器也可能拒绝允许同一个连接上有多个请求，在这种情况下，连接会为每个请求重新创建，且不能被放入连接池。Agent仍然会创建请求到服务器，但每个请求会出现在一个先的连接。、
		但一个客户端或服务器关闭时，它会被移出连接池。连接池中任何未被使用的socket会被释放，从而使nodejs进程在没有请求时不用保存运行。

		当Agent实例不再被使用时，建议destroy()它，因为未被使用的socket也会消耗操作系统资源。

		当socket触发'close'事件或'agentRemove'事件时，它会被移出代理池。当打算长时间保持打开一个HTTP请求且不想它留着连接池中，可以做如下处理

		http.get(options, (res) => {
		//处理事情
		}).on('socket', (socket) => {
			socket.emit('agentRemove');
		})

		代理页可被用于单独请求，使用{agent:false}作为http.get()函数或者http.request()函数的选项，则会为客户端连接创建一个默认配置的一次性使用的Agent.

		http.get({
			hostname:'localhost',
			port:80,
			path:'/',
			agent:false    //创建一个新的代理，只用于本次请求
		}, (res) => {
		//对响应进行处理
		})

	3.2 new Agent([options])
		options代理的配置选项，有以下字段：
			keepAlive<boolean>保持socket可用即使没有请求，以便它们可被将来的请求使用而无需重新建立一个TCP连接。默认为false
			keepAliveMsecs<number>当使用了keepAlive选项时，该选项指定TCP Keep-Alive数据包的初始延迟。当keepAlive选项为false或undefined时，该选项无效。默认为1000
			maxSocket<number>每个主机允许的最大socket数量。
			maxFreeSockets<number>在空闲状态下允许打开的最大socket数量。仅当keepAlive为true时才有效

			若要配置其中任何一个，则需要创建自定义的http.Agent实例
			const http = require('http');
			const keepAliveAgent = new http.Agent({keepAlive: true});
			options.agent = keepAliveAgent;
			http.request(options, onResponseCallback);

	3.3 agent.createConnection(options[,callback])
		options<object> 包含连接详情的选项。
		返回<net.Socket>
		创建一个用于HTTP请求的socket或流。
		socket或流可以通过以下两种方式获取：从该函数返回，或传入callback.

	3.4 agent.keepSocketAlive(socket)
	3.5 agent.destroy()
		销毁当前正被代理使用的任何socket.
	3.6 agent.freeSockets
		返回一个对象，包含当前正在等待被启用了keepAlive的代理使用的socket数组。不要修改该属性

	3.7 agent.getName(options)
		options<object>为名称生成程序提供信息的选项。

		为请求选项的集合获取一个唯一的名称，用来判断一个连接是否可以被复用。对于HTTP代理，返回host:port:localAddress.对于HTTPS代理，

	3.8 http.ClientRequest类
		该对象在http.request()内部被创建并返回。它表示着一个正在处理的请求，其请求头已进入队列。请求头仍可使用setHeader(name.value)、getHeader(name)和removeHeader(name)API进行修改。实际的请求头会与第一个数据块一起发送或当关闭连接时发送。

		要获取响应，需为'response'事件添加一个监听器到请求对象上。当响应头被接收到时，'response'事件会从请求对象上被触发。'response'事件被执行时带有一个参数，该参数是一个http.IncominMessage实例。
		在'response'事件期间，可以添加监听器到响应对象上，比如监听'data'事件

		如果没有添加'response'事件处理函数，则响应会被整个丢弃。如果添加了'response'事件处理函数，则必须消耗完响应对象的数据，可通过调用response.read()、或添加一个'data'事件处理函数、或调用.resume()方法。数据被消耗完时会触发'end'事件。在数据被读取完之前会消耗内存，可能会造成'process out of memory'错误。

	3.9 abort 事件
		当请求已被客户端终止时触发。
	3.10 aborted事件
		当请求被服务器终止且网络socket已关闭时触发。
	3.11 connet事件
		每当服务器响应connet 请求时触发。如果该事件未被监听，则接收到CONNECT方法的客户端会关闭连接。

		const http = require('http');
		const net = require('net');
		const url = require('url');

		//创建一个HTTP代理服务器
		const proxy = http.createServer((req, res) => {
			res.writeHead(200, {'Content-Type': 'text/plain'});
			res.end('okay');
		});

		proxy.on('connect', (req, cltSocket, head) => {
			//连接一个服务器
			const srvUrl = url.parse('http://${req.url}');
			const srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () => {
				cltSocket.write('HTTP/1.1 200 Connection Established\r\n' + 'Proxy-agent: Node.js-proxy\r\n' + '\r\n');
				srvSocket.write(head);
				srvSocket.pipe(cltSocket);
				cltSocket.pipe(srvSocket);
			});
		});

		//代理服务器正在运行
		proxy.listen(1337,'127.0.0.1', () => {
			const options = {
				port:1337,
				hostname:'127.0.0.1',
				method:'CONNECT',
				path:'www.google.com:80'
			};

			const req = http.request(options);
			req.end();

			req.on('connect', (res,socket,head) => {
				console.log('已连接！');

				//通过代理服务器发送一个请求
				socket.write('GET / HTTP/1.1\r\n' +
							'Host: www.google.com:80\r\n' +
							'Connection: close\r\n' + '\r\n');
				socket.on('data', (chunk) => {
					cosole.log(chunk.toString());
				});
				socket.on('end', () => {
					proxy.close();
				});
			});
		});

4.Child Processes(子进程)
	child_process模块提供了衍生子进程的功能，它与popen类似，但不完全相同。

	默认情况下，在Nodejs的父进程与衍生的子进程之间会建立stdin、stdout和stderr的管道。数据能以飞阻塞的方式在管道中流通。注意，有些程序会在内部使用缓冲I/O.虽然这不影响NODEJS,但这意味着子进程的数据可能无法被立即使用

	child_process.spawn()方法会异步地衍生子进程，且不会阻塞Node.js事件循环。
	child_process.spawnSync()方法则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或终止。
	
	4.1 child_process.fork()
		该方法是child_process.spawn()的一个特殊情况，专门用于衍生新的nodejs进程。

	4.2 options.detached
		在windows上，设置options.detached为true可以使子进程在父进程退出后继续运行。子进程有自己的控制台窗口。一旦启用一个子进程，它将不能被禁用。
		在非windows平台上，如果将options.detached设为true，则子进程会成为新的进程组和会话的领导者。注意，子进程在父进程退出后可以继续运行，不管它们是否被分离。

	4.3 options.stdio 选项用于配置子进程与父进程之间建立的管道。